#######################################################################################################################
##   _______   _                      __     __             _    
##  / ___/ /  (_)__  __ _  __ _____  / /__  / /  ___  ___ _(_)___ TM
## / /__/ _ \/ / _ \/  ' \/ // / _ \/  '_/ / /__/ _ \/ _ `/ / __/                  ////  O P E N - S O U R C E ////
## \___/_//_/_/ .__/_/_/_/\_,_/_//_/_/\_\ /____/\___/\_, /_/\__/ 
##           /_/                                    /___/                                    chipmunklogic.com
#######################################################################################################################
# Script           : peqFlash, Pequeno Flasher
# Developer        : Mitu Raj, chip@chipmunklogic.com
# Vendor           : Chipmunk Logic™, https://chipmunklogic.com
#
# Description      : peqFlash is used to flash instruction & data binary files to Pequeno subsystem via 
#                    UART programming IF and boot the system.
#                    >> Binary files  : IMEM & DMEM binary files generated by pqr5asm.
#                    >> Target device : PQR5 v1.0 subsystem
#                    Flags while invoking the script:
#                    -serport <arg>    : Serial port to which the target is connected
#                    -baud <arg>       : Baudrate of serial communication in bps
#                    -imembin <arg>    : IMEM binary file path
#                    -dmembin <arg>    : DMEM binary file path
#                    -reloc <arg>      : [OPTIONAL] Relocates the program to given memory address in IMEM
#                    -cleanimem        : [OPTIONAL] Cleans IMEM with NOP instructions before writing the binary/reboot
#                    -rebootonly       : [OPTIONAL] Overrides input binary files, and reboot with existing binary
#                    Refer to userguide, "Programming_Pequeno_with_peqFlash", for more details. 
#
# Last modified on : August-2024
# Compatiblility   : Python 3.9 tested
#
# Copyright        : Open-source license
#######################################################################################################################
# Import Libraries 
import argparse
import sys
import os
import time
import serial

# Global vars
is_reloc = False
is_ser_open = False
mytimeout = 10
CMD_REQ_DEVC_SIGN = bytes([0xD3])
CMD_BOOT_REQ_IMEM_CLN = bytes([0xB1])
CMD_BOOT_REQ = bytes([0xB0])
SUCCESS = bytes([0x55])          
ERR_CMD_INVALID = bytes([0xEC])
ERR_PGM = bytes([0xED])   
ERR_POSTAMBLE = bytes([0xEE])
DEVC_SIGN = b'\xC0\xDE\x4A\x11'
IPREAMBLE = b'\xC0\xC0\xC0\xC0'
DPREAMBLE = b'\xD0\xD0\xD0\xD0'
POSTAMBLE = b'\xE0\xE0\xE0\xE0'

# Function to print welcome message
def print_welcome():
    print('')   
    print("                     _______________               ______  TM  ")      
    print(" ___________________ ___  ____/__  / ______ __________  /_     ")  
    print(" ___  __ \  _ \  __ `/_  /_   __  /  _  __ `/_  ___/_  __ \    ")  
    print(" __  /_/ /  __/ /_/ /_  __/   _  /___/ /_/ /_(__  )_  / / /    ")  
    print(" _  .___/\___/\__, / /_/      /_____/\__,_/ /____/ /_/ /_/     ")  
    print(" /_/            /_/                                            ")
    print("                           - Flasher for Pequeno RISC-V CPU")                    
    print("===============================================================") 
    print(" Chipmunk Logic (TM) 2024")    
    print(" Visit us: chipmunklogic.com")
    print("===============================================================")    
    print('')

# Function to print PASS
def print_pass(): 
    print('')     
    print('______________________________')
    print('___  __ \__    |_  ___/_  ___/')
    print('__  /_/ /_  /| |____ \_____ \ ')
    print('_  ____/_  ___ |___/ /____/ / ')
    print('/_/     /_/  |_/____/ /____/  ')                           
    print('')                                                    
                                                                                                        
# Function to print FAIL
def print_fail(): 
    print('')     
    print('_____________________________  ')       
    print('___  ____/__    |___  _/__  /  ')   
    print('__  /_   __  /| |__  / __  /   ')   
    print('_  __/   _  ___ |_/ /  _  /___ ')   
    print('/_/      /_/  |_/___/  /_____/ ') 
    print('')      

# Function to exit with success
def exitsucc(isreboot = False):    
    global is_ser_open
    print_pass()
    if is_ser_open:
        ser.close()
        is_ser_open = False
        print(f"\nSerial port {ser.name} closed.")
    if not isreboot:        
        print("Program upload completed successfully!! :)")    
    exit(0)

# Function to exit with failure
def exitfail():    
    global is_ser_open
    #print_fail()
    if is_ser_open:
        ser.close()
        is_ser_open = False
        print(f"\nSerial port {ser.name} closed.")    
    print('Program upload failed :(')
    print('Exiting with ERROR(s)...')    
    exit(1)

# Class for argument parser
class CustomArgumentParser(argparse.ArgumentParser):
    def error(self, message):
        sys.stderr.write(f'\npeqFlash>> [ERROR] {message}\n')
        sys.stderr.write(f'Usage: python peqflash.py -serport <port> -baud <baudrate> [-imembin <IMEM bin file>] \
[-dmembin <DMEM bin file>] [-reloc <address>] [-cleanimem] [-rebootonly]\n')
        sys.exit(1)

# Function to parse arguments
def parse_arguments():
    global is_reloc
    parser = CustomArgumentParser(description='Pequeno Flasher')
    #parser = argparse.ArgumentParser(description='Pequeno Flasher')

    # Required arguments
    parser.add_argument('-serport', required=True, help='Serial port to which the target is connected (e.g., COM1)')
    parser.add_argument('-baud', required=True, type=int, help='Baudrate of serial communication in bps (e.g., 9600)')

    # Optional arguments
    parser.add_argument('-imembin', help='IMEM binary file path')  # Mandatory argument if no -rebootonly
    parser.add_argument('-dmembin', help='DMEM binary file path')  # Mandatory argument if no -rebootonly
    parser.add_argument('-reloc', help='Relocates the program to given memory address in IMEM (0x<addr> or integer)')
    parser.add_argument('-cleanimem', action='store_true', help='Cleans IMEM with NOP instructions before writing the binary')
    parser.add_argument('-rebootonly', action='store_true', help='Overrides input binary files, and reboot with existing binary')

    args = parser.parse_args()

    # Custom validation: If -reloc is set, a relocation address must be provided
    if args.reloc is not None and not args.reloc.strip():
        parser.error('peqFlash>> [ERROR] -reloc requires a relocation address.')
        is_reloc = False
    elif args.reloc is not None:
        is_reloc = True

    # Custom validation: If -rebootonly is not set, -imembin and -dmembin are required
    if not args.rebootonly:
        if not args.imembin:
            parser.error('peqFlash>> [ERROR] -imembin is required.')
        if not args.dmembin:
            parser.error('peqFlash>> [ERROR] -dmembin is required.')

    # Additional validation for binary file existence
    if not args.rebootonly:
        is_file_bin = args.imembin.lower().endswith('.bin')   
        if not is_file_bin:
            parser.error(f'peqFlash>> [ERROR] IMEM binary file {args.imembin} is not .bin type')
        is_file_bin = args.dmembin.lower().endswith('.bin')
        if not is_file_bin:
            parser.error(f'peqFlash>> [ERROR] DMEM binary file {args.imembin} is not .bin type')
        if args.imembin and not os.path.isfile(args.imembin):
            parser.error(f'peqFlash>> [ERROR] IMEM binary file {args.imembin} does not exist!!')
        if args.dmembin and not os.path.isfile(args.dmembin):
            parser.error(f'peqFlash>> [ERROR] DMEM binary file {args.dmembin} does not exist!!')

    return args

# Function to verify binary file
def verify_binary_file(preamble, postamble, bindata):
    # Size of data   
    bindata_bytes = len(bindata)

    # Validate minimum file content size = 16 bytes
    if bindata_bytes < 16:
        #print('File size validation failed')
        return 1
    
    # Validate first four bytes = preamble
    if bindata[0:4] != preamble:        
        #print('Preamble validation failed')
        return 1
    
    # Validate last four bytes = postamble
    if bindata[-4:] != postamble:
        #print('Postamble validation failed')
        return 1
    
    # Extract program size and program base address
    program_size = int.from_bytes(bindata[4:8], byteorder='big')
    program_base_addr = int.from_bytes(bindata[8:12], byteorder='big')

    # Validate file content size = program size + 16
    if bindata_bytes != program_size + 16:
        #print('Program size validation failed')
        return 1
    
    # If all validations pass, return 0
    return 0

# Function to display progress bar
def display_progress_bar(current, maximum):
    # Calculate the percentage
    percentage = int((current / maximum) * 100)
    
    # Ensure percentage is within valid bounds
    if percentage < 0:
        percentage = 0
    elif percentage > 100:
        percentage = 100
    
    # Use the Unicode solid block character '█'
    progress_char = '█'
    total_slots = 20
    
    # Calculate the number of filled and empty slots
    filled_slots = int((percentage / 100) * total_slots)
    empty_slots = total_slots - filled_slots
    
    # Create the progress bar string
    progress_bar = progress_char * filled_slots + '.' * empty_slots
    
    # Print the progress bar with percentage, overwriting the previous line
    sys.stdout.write(f"{progress_bar} {percentage}%")
    if percentage != 100:
        sys.stdout.flush()
        # Move cursor to the beginning of the line
        sys.stdout.write('\r')
    else:
        print(f' DONE ({current}/{maximum} bytes)')

################################################### MAIN ##############################################################
# Parse & validate arguments
try:
    args = parse_arguments()  
    if is_reloc:          
        unalign_reloc_addr = int(args.reloc, 0)  
        reloc_addr = ((unalign_reloc_addr + 3) // 4) * 4        
        reloc_addr_bytes = reloc_addr.to_bytes(4, byteorder='big', signed=False)
    else:
        reloc_addr = None
except SystemExit as e:  # Catch exit() exception from fn call
    print('\npeqFlash>> Run python peqflash.py --help for more details.')
    print('Exiting with ERROR(s)...')    
    exit(1) 
except (ValueError, OverflowError) as e:
    print('peqFlash>> [ERROR] -reloc has illegal valued argument')
    print('Run python peqflash.py --help for more details.')
    print('Exiting with ERROR(s)...')    
    exit(1)
    
# Store parsed arguments
print('\npeqFlash>> [INFO] Successfully parsed all arguments!!')
print('Launching flasher...')
print_welcome()
serport = args.serport
baud = int(args.baud)
imembin = args.imembin
dmembin = args.dmembin
#reloc_addr already saved
cleanimem = args.cleanimem
rebootonly = args.rebootonly

# Print configuration
print('\nFLASH CONFIGURATION:')
print('')
print(f'{"Serial port":23} {serport}')
print(f'{"Baudrate":23} {baud}')
print(f'{"IMEM binary file":23} {imembin}')
print(f'{"DMEM binary file":23} {dmembin}')
print(f'{"Relocation of program":23} {"YES" if is_reloc else "NO"}')
if is_reloc:
    print(f'{"Relocation address":23} 0x{reloc_addr:08X}')
else:
    print(f'{"Relocation address":23} -')
print(f'{"Clean IMEM":23} {"YES" if cleanimem else "NO"}')
print(f'{"Reboot only":23} {"YES" if rebootonly else "NO"}')
print('')

# Open the serial port and establish the serial communication link
try:
    print("Establishing the communication link...")
    ser = serial.Serial(serport, baud, parity=serial.PARITY_NONE, timeout=mytimeout)
    if ser.is_open:
        is_ser_open = True
        print(f"Serial port {ser.name} opened successfully.")
    else:
        is_ser_open = False
        print(f"Failed to open serial port {ser.name}")            
        sys.exit(1)
except Exception as e:
    print(f"ERROR opening serial port {serport}")
    exitfail()    

#### STEP1: Verify Device signature ####
try:    
    # Send command: Device signature request
    command = CMD_REQ_DEVC_SIGN
    ser.reset_input_buffer()  # Clear the serial buffer first
    ser.write(command)
    print("\nVerifying Device signature...")

    # Wait for the response
    response = ser.read(4)  # Read 4 bytes from the serial port, first byte = MSB of response
    resp_len = len(response)
    if resp_len == 4:
        if response == DEVC_SIGN:
            print(f"Device signature: {response.hex().upper()} verified successfully.")
        else:
            print("Device signature verification failed :(")               
            sys.exit(1)
    else:
        print("Incomplete/no response received, comm. link TIMED OUT!!")   
        print("Device signature verification failed :(")         
        sys.exit(1)
except serial.SerialException as e:
    print(f"\npeqFlash>> [ERROR] Serial port connection lost @{ser.name}!!")     
    exitfail()
except Exception as e:
    exitfail()

#### STEP2: Validation of Binary ####
# Validate binary files if binary loading mode is requested
print("\nValidating the binary files...")
if not rebootonly:
    try:
        # Open the binary files and convert to byte arrays
        f_imembin = open(imembin, "rb")
        imembin_data = bytearray(f_imembin.read())
        f_dmembin = open(dmembin, "rb")
        dmembin_data = bytearray(f_dmembin.read())
    except Exception as e:
        print('Unable to open the binary files.')
        exitfail()

    # Verify the binary file structure
    fbinsts = verify_binary_file(IPREAMBLE, POSTAMBLE, imembin_data)
    if fbinsts:
        print('IMEM binary file validation failed.')
        exitfail()
    print(f'IMEM binary file validation successful, size = {len(imembin_data)} bytes.')
    fbinsts = verify_binary_file(DPREAMBLE, POSTAMBLE, dmembin_data)
    if fbinsts:
        print('DMEM binary file validation failed.')
        exitfail()
    print(f'DMEM binary file validation successful, size = {len(dmembin_data)} bytes.')

#### STEP3: IMEM clean ####
# Perform IMEM clean if IMEM clean slate is requested
if cleanimem:
    try:    
        # Send command: IMEM clean request
        command = CMD_BOOT_REQ_IMEM_CLN
        ser.reset_input_buffer()  # Clear the serial buffer first
        ser.write(command)
        print("\nRequesting IMEM clean...")

        # Wait for the response
        response = ser.read(1)  # Read 1 byte from the serial port, first byte = MSB of response
        resp_len = len(response)
        if resp_len == 1:
            if response == SUCCESS:
                print("IMEM clean done successfully with NOP instructions.")                
            else:
                print("IMEM clean request failed.")               
                sys.exit(1)
        else:
            print("Incomplete/no response received, comm. link TIMED OUT!!")   
            print("IMEM clean request failed.")         
            sys.exit(1)
    except serial.SerialException as e:
        print(f"\npeqFlash>> [ERROR] Serial port connection lost @{ser.name}!!")     
        exitfail()
    except Exception as e:
        exitfail()

# If IMEM clean + reboot only request, nothing further to do...
if cleanimem and rebootonly:
    exitsucc()

# If reboot only request, boot the CPU with existing binary and exit...
if rebootonly:
    try:    
        # Send command: Boot request
        command = CMD_BOOT_REQ
        ser.reset_input_buffer()  # Clear the serial buffer first
        ser.write(command)
        print("\nRequesting reboot...")

        # Wait for the response
        response = ser.read(1)  # Read 1 byte from the serial port, first byte = MSB of response
        resp_len = len(response)
        if resp_len == 1:
            if response == SUCCESS:
                print("Reboot done successfully.")                
            else:
                print("Reboot failed.")               
                sys.exit(1)
        else:
            print("Incomplete/no response received, comm. link TIMED OUT!!")   
            print("Reboot failed.")         
            sys.exit(1)
    except serial.SerialException as e:
        print(f"\npeqFlash>> [ERROR] Serial port connection lost @{ser.name}!!")     
        exitfail()
    except Exception as e:
        exitfail()
    exitsucc(True)  # Nothing further to do...

print("\nPreparing to flash...")

#### STEP4: Flash IMEM ####
# Update the program base address if relocation is requested...
if is_reloc:        
    imembin_data[8] = reloc_addr_bytes[0]
    imembin_data[9] = reloc_addr_bytes[1]
    imembin_data[10] = reloc_addr_bytes[2]
    imembin_data[11] = reloc_addr_bytes[3]

# Send binary
try:
    total_binsize = len(imembin_data)
    prog_binsize = 0    
    print('\nFlashing binary to IMEM:')
    # Iterate over each byte in the data array
    for curr_byte in imembin_data:
        ser.write(bytes([curr_byte]))  # Send each byte
        prog_binsize = prog_binsize + 1
        if prog_binsize % 4 == 0:
            display_progress_bar(prog_binsize, total_binsize)

    # Wait for the response
    response = ser.read(1)  # Read 1 byte from the serial port, first byte = MSB of response
    resp_len = len(response)
    if resp_len == 1:
        if response == SUCCESS:
            print("Flashed successfully.")                
        else:            
            print(f"Flashing failed with ERROR code = 0x{response.hex().upper()}")               
            sys.exit(1)
    else:
        print("Incomplete/no response received, comm. link TIMED OUT!!")  
        print("Flashing failed.")     
        sys.exit(1)
except serial.SerialException as e:
        print(f"\npeqFlash>> [ERROR] Serial port connection lost @{ser.name}!!")     
        exitfail()
except Exception as e:
    exitfail()

#### STEP5: Flash DMEM ####
# Send binary
try:
    total_binsize = len(dmembin_data)
    prog_binsize = 0    
    print('\nFlashing binary to DMEM:')
    # Iterate over each byte in the data array
    for curr_byte in dmembin_data:
        ser.write(bytes([curr_byte]))  # Send each byte
        prog_binsize = prog_binsize + 1
        if prog_binsize % 4 == 0:
            display_progress_bar(prog_binsize, total_binsize)

    # Wait for the response
    response = ser.read(1)  # Read 1 byte from the serial port, first byte = MSB of response
    resp_len = len(response)
    if resp_len == 1:
        if response == SUCCESS:
            print("Flashed successfully.")                
        else:            
            print(f"Flashing failed with ERROR code = 0x{response.hex().upper()}")               
            sys.exit(1)
    else:
        print("Incomplete/no response received, comm. link TIMED OUT!!")  
        print("Flashing failed.")     
        sys.exit(1)
except serial.SerialException as e:
        print(f"\npeqFlash>> [ERROR] Serial port connection lost @{ser.name}!!")     
        exitfail()
except Exception as e:
    exitfail()

# COMPLETED flashing the program successfully!
exitsucc()