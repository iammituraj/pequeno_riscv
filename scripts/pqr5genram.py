#############################################################################################################
# ╔═╦╗╔╗─────────╔╗─╔╗────╔╗
# ║╔╣╚╬╬═╦══╦╦╦═╦╣╠╗║║╔═╦═╬╬═╗
# ║╚╣║║║╬║║║║║║║║║═╣║╚╣╬║╬║║═╣ /////////////// O P E N S O U R C E
# ╚═╩╩╩╣╔╩╩╩╩═╩╩═╩╩╝╚═╩═╬╗╠╩═╝
# ─────╚╝───────────────╚═╝
#############################################################################################################
# Script           : pqr5 generate RAM
# Developer        : Mitu Raj, chip@chipmunklogic.com
# Vendor           : Chipmunk Logic™, https://chipmunklogic.com
#
# Description      : This script generates Single-port RAM in SV which is initialized with hex values
#                    on power-on on FPGA Block RAMs. The scripts reads two source files: 
#                    -- Hex/Bin code file in ASCII text format: *_hex.txt or *_bin.txt
#                    -- Reference RAM file in SV
#                    And outputs a single file:
#                    -- Generated RAM in SV
#                    Invoking the script from terminal:
#                       python pqr5genram.py '<arg1> <arg2> <arg3> <arg4> <arg5>'
#                       <arg1> = Hex/Bin code file path
#                       <arg2> = Reference RAM file path
#                       <arg3> = Generated RAM module's name
#                       <arg4> = Generated RAM's depth
#                       <arg5> = Generated RAM's data width
#                       <arg6> = Offset address where first data is initialized
#                       // If no arguments provided, source files = ./sample_hex.txt, ./ram.sv
#
# Last modified on : Jan-2024
# Compatiblility   : Python 3.9 tested
#
# Copyright        : Open-source license, see developer.txt.
#############################################################################################################

# Import Libraries
import sys

# Function to print welcome message
def print_welcome():
    print('+===================================+')
    print('|      Chipmunk Logic (TM) 2024     |')
    print('+===================================+')
    print('|~~~~~~ GENRAM: RAM Generator ~~~~~~|')
    print('|/////// O P E N S O U R C E ///////|')
    print('+===================================+')


# Source and Destination file paths
# Decode from command line arguments
print_welcome()
try:
    # No. of arguments = len(sys.argv)-1
    f_hex_src_path = sys.argv[1]  # Source file 1: Hex/Bin code file
    f_ram_src_path = sys.argv[2]  # Source file 2: Reference RAM file in SV
    gen_module = sys.argv[3]      # Generated RAM module's name
    ram_depth = sys.argv[4]       # Generated RAM's depth
    ram_width = sys.argv[5]       # Generated RAM's data width
    offset = sys.argv[6]          # Offset address where first data is initialized
    f_des_path = f_ram_src_path.replace('\\', '/')
    f_des_path_l = list(f_des_path.split('/'))
    f_des_path_l [-1] = ''
    f_des_path = "/".join(f_des_path_l) + str(gen_module) + '.sv'  # Destination file: Generated RAM in SV
except:
    # Default parameters
    print('| INFO : No arguments/unsupported arguments, proceeding with default files...')
    f_hex_src_path = './sample_hex.txt'
    f_ram_src_path = './ram.sv'
    gen_module = 'genram'
    ram_depth = 1024
    ram_width = 32
    offset = 0
    f_des_path = './genram.sv'

# Open all files
try:
    f_hex_src = open(f_hex_src_path, "r", encoding="utf8")
    f_ram_src = open(f_ram_src_path, "r", encoding="utf8")
    f_des = open(f_des_path, "w")
except:
    print("| FATAL: Files cannot be opened! Please check the path/permissions...")
    exit(1)

if (f_hex_src_path.endswith('_hex.txt') or f_hex_src_path.endswith('_bin.txt')) and \
   (f_ram_src_path.endswith('.sv') or f_ram_src_path.endswith('.v')):
    print('\n| INFO : Opened all files successfully...')
    if f_hex_src_path.endswith('_hex.txt'):
        is_hex = 1
    else:
        is_hex = 0
else:
    print('| ERROR: Unsupported files or files have errors!')
    exit(1)

# Read and store contents of files (data)
hex_src = f_hex_src.read().splitlines()
ram_src = f_ram_src.read().splitlines()

data_size = len(hex_src)

if (data_size > int(ram_depth)) or (data_size > (int(ram_depth)-int(offset))):
    print('| WARNG: Hex/Bin file contains more data than the RAM could accomodate...')
if int(offset) >= int(ram_depth):
    print('| FATAL: Offset address is beyond the addressing range of generated ram...')
    exit(2)

# Form the destination file content data array
des = []
d = 0
for line in ram_src:    
    if line.startswith('module'):
        des.append('module ' + gen_module + '#(')
    elif line.startswith('endmodule'):
        des.append('//**AUTOGENERATED**//')
        des.append('// Supported for initialization by most FPGA Block RAMs')
        des.append('initial begin')
        for addr in range(data_size):
            maddr = addr + int(offset)
            if is_hex:
                des.append("   ram" + "[" + str(maddr) + "] = " + str(ram_width) + "'h" + hex_src[addr] + " ;")
            else:
                des.append("   ram" + "[" + str(maddr) + "] = " + str(ram_width) + "'b" + hex_src[addr] + " ;")
            # Loop breaker to avoid data assignment to invalid addr locations
            d = d + 1           
            if (d == int(ram_depth)) or (maddr == int(ram_depth)-1):
                break                
        des.append('end')
        des.append('//**AUTOGENERATED**//')
        des.append('')
        des.append('endmodule')
    elif len(line.split()) > 0 and line.split()[0] == 'parameter' and line.split()[1] == 'DEPTH':
        des.append('   parameter  DEPTH  = ' + str(ram_depth) + ' ,    // Depth of RAM //**AUTOGENERATED**//')
    elif len(line.split()) > 0 and line.split()[0] == 'parameter' and line.split()[1] == 'DATA_W':
        des.append('   parameter  DATA_W = ' + str(ram_width) + ' ,    // Data width //**AUTOGENERATED**//')
    else:
        des.append(line)      

# Write to destination file
for line in des:
    #print(line)
    f_des.write(line + '\n')  # Because string list doesn't contain '\n' characters, all trimmed by  splitline()

print('| INFO : Generated RAM and written to SV file successfully...')
print('\n|| Success || Generated RAM of ', ram_depth, 'x ', ram_width, ' bit')